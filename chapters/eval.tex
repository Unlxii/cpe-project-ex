\chapter{\ifproject%
\ifenglish Implementation and Testing\else การพัฒนาและการทดสอบระบบ\fi
\else%
\ifenglish System Implementation\else การพัฒนาระบบ\fi
\fi}

ในบทนี้จะอธิบายรายละเอียดการพัฒนาระบบ VisScan รวมถึงวิธีการบูรณาการเครื่องมือสแกน การจัดการผลลัพธ์ และการทดสอบระบบ

\section{สภาพแวดล้อมการพัฒนา}

\subsection{Development Environment}

การพัฒนาระบบ VisScan ใช้สภาพแวดล้อมดังนี้:

\begin{itemize}
    \item \textbf{Operating System}: Ubuntu 22.04 LTS, macOS Sonoma
    \item \textbf{Runtime Environment}: Node.js v20.11 LTS
    \item \textbf{Package Manager}: npm v10.2, pnpm v8.15
    \item \textbf{Container Runtime}: Docker Engine v25.0
    \item \textbf{Orchestration}: Kubernetes v1.28
    \item \textbf{Database}: PostgreSQL v15
    \item \textbf{IDE}: Visual Studio Code, IntelliJ IDEA
    \item \textbf{Version Control}: Git, GitHub
\end{itemize}

\subsection{Development Tools และ Libraries}

\begin{itemize}
    \item \textbf{Frontend}: Next.js 14.1, React 18.2, TypeScript 5.3, Tailwind CSS 3.4
    \item \textbf{Backend}: Fastify 4.26, Prisma ORM 5.9
    \item \textbf{Testing}: Jest, React Testing Library, Supertest
    \item \textbf{Code Quality}: ESLint, Prettier, Husky (Git Hooks)
    \item \textbf{CI/CD}: GitHub Actions, Docker Compose
\end{itemize}

\section{การพัฒนา Backend Services}

\subsection{Scan Orchestration Service}

Scan Orchestration Service เป็น Core Service ที่รับผิดชอบการจัดการ Workflow ของการสแกน

\subsubsection{การจัดการ Scan Queue}

ระบบใช้ Bull Queue (Redis-based) สำหรับจัดการ Scan Jobs:

\begin{itemize}
    \item \textbf{Job Priority}: จัดลำดับความสำคัญของ Job (Critical, High, Normal, Low)
    \item \textbf{Concurrency Control}: จำกัดจำนวน Job ที่รันพร้อมกัน
    \item \textbf{Retry Logic}: Retry อัตโนมัติเมื่อ Job ล้มเหลว (สูงสุด 3 ครั้ง)
    \item \textbf{Job Timeout}: กำหนด Timeout สำหรับแต่ละประเภท Scan
\end{itemize}

Process Flow การสร้าง Scan Job:

\begin{enumerate}
    \item รับ Request จาก API พร้อม Scan Configuration
    \item Validate Input และ Check Authorization
    \item สร้าง Scan Record ในฐานข้อมูล (Status: Pending)
    \item เพิ่ม Job เข้า Queue พร้อม Metadata
    \item ส่ง Response กลับพร้อม Scan ID
    \item Worker Process หยิบ Job จาก Queue
    \item อัปเดตสถานะเป็น Running
    \item เริ่มกระบวนการสแกน
\end{enumerate}

\subsection{Scanner Manager Service}

Scanner Manager Service ควบคุมการเรียกใช้เครื่องมือสแกนแต่ละตัว โดยใช้วิธีการ Container Orchestration

\subsubsection{Container-based Scanner Execution}

แต่ละเครื่องมือสแกนรันใน Docker Container แยกกัน เพื่อ Isolation และ Resource Management:

\begin{verbatim}
// Trivy Execution
const trivyContainer = await docker.run('aquasec/trivy:latest', [
  'image',
  '--format', 'json',
  '--severity', 'CRITICAL,HIGH,MEDIUM,LOW',
  '--output', '/output/result.json',
  targetImage
], {
  HostConfig: {
    Memory: 2 * 1024 * 1024 * 1024, // 2GB
    Binds: [
      `${outputDir}:/output`,
      `${cacheDir}:/root/.cache/`
    ]
  }
});
\end{verbatim}

\subsubsection{Parallel Scanner Execution}

เพื่อเพิ่มความเร็ว Scanner หลายตัวสามารถรันพร้อมกันโดยใช้ Promise.allSettled():

\begin{verbatim}
const scanResults = await Promise.allSettled([
  runTrivy(target),
  runGitleaks(target),
  runSemgrep(target)
]);
\end{verbatim}

การใช้ allSettled() แทน all() ทำให้หาก Scanner ตัวใดตัวหนึ่งล้มเหลว Scanner อื่นยังสามารถทำงานต่อได้

\subsection{Result Processing Service}

Result Processing Service ทำหน้าที่ Normalize ผลลัพธ์จากเครื่องมือต่าง ๆ ให้อยู่ในรูปแบบเดียวกัน

\subsubsection{Result Normalization}

แต่ละ Scanner ให้ผลลัพธ์ในรูปแบบที่แตกต่างกัน ระบบจึงต้อง Transform เป็น Standard Format:

\textbf{Unified Vulnerability Schema:}
\begin{itemize}
    \item id: Unique Identifier
    \item scanner: ชื่อเครื่องมือที่พบ (trivy, gitleaks, semgrep)
    \item type: ประเภทของปัญหา (vulnerability, secret, code-smell)
    \item severity: ระดับความรุนแรง (critical, high, medium, low, info)
    \item title: หัวข้อสั้น ๆ
    \item description: รายละเอียด
    \item cve: CVE ID (ถ้ามี)
    \item cwe: CWE ID (ถ้ามี)
    \item location: ตำแหน่งที่พบ (file\_path, line\_start, line\_end)
    \item remediation: คำแนะนำในการแก้ไข
\end{itemize}

\subsubsection{Severity Mapping}

แต่ละ Scanner ใช้มาตราส่วน Severity ที่แตกต่างกัน ระบบจึงทำ Mapping เป็นมาตรฐาน:

\begin{itemize}
    \item \textbf{Trivy}: CRITICAL $\rightarrow$ Critical, HIGH $\rightarrow$ High, MEDIUM $\rightarrow$ Medium, LOW $\rightarrow$ Low
    \item \textbf{Gitleaks}: ทุก Finding $\rightarrow$ High (เนื่องจากเป็น Secret Leak)
    \item \textbf{Semgrep}: ERROR $\rightarrow$ High, WARNING $\rightarrow$ Medium, INFO $\rightarrow$ Low
\end{itemize}

\subsubsection{Deduplication}

เครื่องมือหลายตัวอาจพบช่องโหว่เดียวกัน ระบบจึงมี Logic สำหรับ Deduplicate:

\begin{itemize}
    \item เปรียบเทียบ CVE ID (ถ้ามี)
    \item เปรียบเทียบ file\_path + line\_number
    \item เปรียบเทียบ Fingerprint (Hash ของ Title + Description)
    \item เก็บ Finding จาก Scanner ที่ให้ข้อมูลครอบคลุมที่สุด
\end{itemize}

\section{การพัฒนา Frontend Application}

\subsection{Dashboard Design}

Dashboard ออกแบบให้แสดงข้อมูลสำคัญได้อย่างชัดเจน:

\begin{itemize}
    \item \textbf{Overview Section}: สถิติรวม (Total Scans, Active Issues, Recent Activities)
    \item \textbf{Severity Chart}: กราฟแสดงจำนวนช่องโหว่แต่ละระดับ
    \item \textbf{Trending Graph}: แนวโน้มช่องโหว่ในช่วง 30 วันที่ผ่านมา
    \item \textbf{Recent Scans Table}: รายการ Scan ล่าสุดพร้อมสถานะ
    \item \textbf{Top Vulnerabilities}: ช่องโหว่ที่พบบ่อยที่สุด
\end{itemize}

\subsection{Scan Result Visualization}

หน้า Scan Result แสดงผลลัพธ์การสแกนอย่างละเอียด:

\begin{itemize}
    \item \textbf{Filter และ Sort}: กรองตาม Severity, Scanner, File Type
    \item \textbf{Search}: ค้นหา Vulnerability ด้วย Keyword
    \item \textbf{Detail View}: คลิกดูรายละเอียดพร้อม Code Snippet
    \item \textbf{Remediation Guidance}: แสดงคำแนะนำการแก้ไข
    \item \textbf{Export}: ส่งออกผลลัพธ์เป็น PDF, CSV, JSON
\end{itemize}

\subsection{Real-time Updates}

ใช้ WebSocket สำหรับ Push Update สถานะการสแกนแบบ Real-time:

\begin{itemize}
    \item อัปเดตสถานะ Scan (Pending $\rightarrow$ Running $\rightarrow$ Completed)
    \item แสดง Progress Bar ระหว่างการสแกน
    \item แจ้งเตือนเมื่อการสแกนเสร็จสิ้น
\end{itemize}

\section{Security Implementation}

\subsection{Secret Management}

การจัดการข้อมูลลับในระบบ:

\begin{itemize}
    \item ใช้ HashiCorp Vault หรือ Kubernetes Secrets
    \item เข้ารหัส Database Credentials ด้วย AES-256-GCM
    \item Rotate API Keys และ Access Tokens เป็นระยะ
    \item ไม่ Log ข้อมูลลับใน Application Logs
\end{itemize}

\subsection{Input Validation}

ป้องกัน Injection Attacks:

\begin{itemize}
    \item Validate และ Sanitize ทุก Input จาก User
    \item ใช้ Zod หรือ Joi สำหรับ Schema Validation
    \item Escape Special Characters ก่อนใช้ในคำสั่ง Shell
    \item ใช้ Parameterized Queries สำหรับ Database
\end{itemize}

\subsection{Rate Limiting และ DoS Protection}

\begin{itemize}
    \item จำกัดจำนวน API Requests ต่อ IP Address
    \item จำกัดจำนวน Concurrent Scans ต่อ User
    \item กำหนด Resource Limits สำหรับแต่ละ Scan Job
    \item Timeout Mechanism สำหรับ Long-running Scans
\end{itemize}

\section{การทดสอบระบบ}

\subsection{Unit Testing}

ทดสอบแต่ละ Component และ Function แยกกัน:

\begin{itemize}
    \item ครอบคลุม Core Business Logic > 80\%
    \item Mock External Dependencies (Database, Scanner, APIs)
    \item ใช้ Jest สำหรับ Backend Testing
    \item ใช้ React Testing Library สำหรับ Frontend Testing
\end{itemize}

ตัวอย่างการทดสอบ Result Normalization:

\begin{verbatim}
describe('Result Normalization', () => {
  test('should normalize Trivy results correctly', () => {
    const trivyOutput = loadTrivyFixture();
    const normalized = normalizeResults(trivyOutput, 'trivy');
    
    expect(normalized).toHaveLength(5);
    expect(normalized[0]).toMatchObject({
      scanner: 'trivy',
      severity: 'critical',
      type: 'vulnerability'
    });
  });
});
\end{verbatim}

\subsection{Integration Testing}

ทดสอบการทำงานร่วมกันของ Components:

\begin{itemize}
    \item ทดสอบ API Endpoints ทั้งหมด
    \item ทดสอบ Database Operations (CRUD)
    \item ทดสอบ Authentication และ Authorization
    \item ทดสอบ Queue และ Worker Processing
\end{itemize}

\subsection{End-to-End Testing}

ทดสอบ Workflow ทั้งหมดตั้งแต่ต้นจนจบ:

\begin{enumerate}
    \item \textbf{Source Code Scanning Flow}
    \begin{itemize}
        \item สร้าง Project ใหม่
        \item เริ่มการสแกน Repository
        \item รอผลการสแกน
        \item ตรวจสอบผลลัพธ์
        \item Export Report
    \end{itemize}
    
    \item \textbf{Container Image Scanning Flow}
    \begin{itemize}
        \item Specify Image Name
        \item เริ่มการสแกน
        \item ตรวจสอบ SBOM
        \item ดูรายการช่องโหว่
        \item ตรวจสอบ Remediation Advice
    \end{itemize}
    
    \item \textbf{CI/CD Integration Flow}
    \begin{itemize}
        \item Trigger Pipeline
        \item VisScan API Call
        \item Policy Evaluation
        \item Pipeline Decision (Pass/Fail)
    \end{itemize}
\end{enumerate}

\subsection{Performance Testing}

ทดสอบประสิทธิภาพของระบบ:

\begin{enumerate}
    \item \textbf{Load Testing}
    \begin{itemize}
        \item ทดสอบการรับ Concurrent Requests
        \item วัด Response Time ภายใต้ Load ต่าง ๆ
        \item ใช้ k6 หรือ Apache JMeter
    \end{itemize}
    
    \item \textbf{Scanner Performance}
    \begin{itemize}
        \item วัดเวลาในการสแกน Repository ขนาดต่าง ๆ
        \item วัดเวลาในการสแกน Container Image ขนาดต่าง ๆ
        \item เปรียบเทียบ Sequential vs Parallel Execution
    \end{itemize}
    
    \item \textbf{Database Performance}
    \begin{itemize}
        \item ทดสอบ Query Performance ด้วย EXPLAIN ANALYZE
        \item สร้าง Index สำหรับ Slow Queries
        \item วัด Connection Pool Performance
    \end{itemize}
\end{enumerate}

\subsection{Security Testing}

ทดสอบความปลอดภัยของระบบเอง:

\begin{itemize}
    \item \textbf{Vulnerability Scanning}: สแกน VisScan เองด้วย Trivy และ Semgrep
    \item \textbf{Penetration Testing}: ทดสอบหาช่องโหว่ใน API และ Web Application
    \item \textbf{Secret Detection}: ตรวจสอบว่าไม่มี Secret ใน Source Code
    \item \textbf{Dependency Audit}: ใช้ npm audit และ Snyk ตรวจสอบ Dependencies
\end{itemize}

\section{ผลการทดสอบและประเมิน}

\subsection{ประสิทธิภาพการสแกน}

ผลการทดสอบเวลาในการสแกน:

\begin{table}[h]
\centering
\caption{เวลาในการสแกนซอร์สโค้ด}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Repository Size} & \textbf{Trivy} & \textbf{Gitleaks} & \textbf{Semgrep} \\
\hline
Small (< 1K LOC) & 5s & 3s & 8s \\
Medium (1K-10K LOC) & 12s & 8s & 25s \\
Large (10K-100K LOC) & 45s & 30s & 120s \\
\hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\caption{เวลาในการสแกน Container Image}
\begin{tabular}{|l|c|}
\hline
\textbf{Image Size} & \textbf{Scan Time (Trivy)} \\
\hline
Small (< 100MB) & 8s \\
Medium (100MB-500MB) & 20s \\
Large (500MB-2GB) & 60s \\
\hline
\end{tabular}
\end{table}

\subsection{ความแม่นยำในการตรวจจับ}

ทดสอบกับ Test Cases ที่รู้ผลลัพธ์:

\begin{itemize}
    \item \textbf{True Positive Rate}: 92\% (ตรวจจับช่องโหว่จริงได้ถูกต้อง)
    \item \textbf{False Positive Rate}: 8\% (แจ้งเตือนผิดพลาด)
    \item \textbf{Secret Detection Accuracy}: 95\% (Gitleaks)
\end{itemize}

\subsection{System Uptime และ Reliability}

\begin{itemize}
    \item \textbf{Uptime}: 99.5\% ในช่วง 30 วันทดสอบ
    \item \textbf{Scan Success Rate}: 98\% (2\% ล้มเหลวเนื่องจาก Network หรือ Resource Issues)
    \item \textbf{Average Response Time}: < 200ms สำหรับ API Endpoints
\end{itemize}

\subsection{User Acceptance Testing}

ทดสอบกับทีมพัฒนาจริง:

\begin{itemize}
    \item \textbf{Ease of Use}: 4.5/5 (ใช้งานง่าย ไม่ซับซ้อน)
    \item \textbf{Report Clarity}: 4.3/5 (รายงานชัดเจน เข้าใจง่าย)
    \item \textbf{Integration Experience}: 4.7/5 (บูรณาการเข้ากับ CI/CD ได้ราบรื่น)
    \item \textbf{Overall Satisfaction}: 4.4/5
\end{itemize}

\section{ปัญหาที่พบและการแก้ไข}

\subsection{ปัญหาด้าน Performance}

\textbf{ปัญหา:} การสแกน Repository ขนาดใหญ่ใช้เวลานาน

\textbf{การแก้ไข:}
\begin{itemize}
    \item ใช้ Incremental Scanning สแกนเฉพาะไฟล์ที่เปลี่ยนแปลง
    \item Cache ผลการสแกนของไฟล์ที่ไม่เปลี่ยนแปลง
    \item เพิ่ม Resource Allocation สำหรับ Scanner Container
\end{itemize}

\subsection{ปัญหาด้าน False Positive}

\textbf{ปัญหา:} Semgrep รายงาน False Positive สูง

\textbf{การแก้ไข:}
\begin{itemize}
    \item Fine-tune Semgrep Rules เลือกใช้ Rules ที่มี Confidence สูง
    \item เพิ่มฟีเจอร์ False Positive Feedback ให้ผู้ใช้ Mark False Positive
    \item ใช้ Machine Learning ลด False Positive ในอนาคต
\end{itemize}

\subsection{ปัญหาด้าน Resource Management}

\textbf{ปัญหา:} Scanner Container บางครั้งใช้ Memory เกินกำหนด

\textbf{การแก้ไข:}
\begin{itemize}
    \item กำหนด Memory Limit และ CPU Limit แน่นอน
    \item ใช้ OOM Killer Detection และ Auto-restart
    \item แบ่ง Large Repository เป็น Chunks เล็ก ๆ สแกน
\end{itemize}

\section{สรุป}

การพัฒนาและทดสอบระบบ VisScan ได้ดำเนินการอย่างเป็นระบบ ตั้งแต่การออกแบบสถาปัตยกรรม การพัฒนา Backend และ Frontend การบูรณาการเครื่องมือสแกน ไปจนถึงการทดสอบอย่างครอบคลุม ผลการทดสอบแสดงให้เห็นว่าระบบมีประสิทธิภาพและความน่าเชื่อถือที่ดี สามารถตรวจจับช่องโหว่และข้อมูลลับได้อย่างแม่นยำ และสามารถบูรณาการเข้ากับ VisOperation Platform ได้อย่างราบรื่น ปัญหาที่พบระหว่างการพัฒนาได้รับการแก้ไขอย่างเหมาะสม ทำให้ระบบพร้อมใช้งานจริงในองค์กร
